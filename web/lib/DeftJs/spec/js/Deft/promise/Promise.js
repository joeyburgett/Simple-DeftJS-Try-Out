// Generated by CoffeeScript 1.3.3
/*
Copyright (c) 2012 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/

/*
Jasmine test suite for Deft.promise.Promise
*/

describe('Deft.promise.Promise', function() {
  var generateCombinations, generatePermutations;
  generatePermutations = function(array) {
    var swap, _generatePermutations;
    swap = function(array, indexA, indexB) {
      var tmp;
      tmp = array[indexA];
      array[indexA] = array[indexB];
      array[indexB] = tmp;
    };
    _generatePermutations = function(array, buffer, start, end) {
      var index, range;
      if (end - start === 1) {
        buffer.push(array.concat());
      } else {
        range = end - start;
        index = 0;
        while (index < range) {
          swap(array, start, start + index);
          _generatePermutations(array, buffer, start + 1, end);
          swap(array, start, start + index);
          index++;
        }
      }
      return buffer;
    };
    return _generatePermutations(array.concat(), [], 0, array.length);
  };
  generateCombinations = function(array) {
    var combinations, index, _generateCombinations;
    _generateCombinations = function(start, array, combination, combinations) {
      var end;
      if (start === 0) {
        if (combination.length > 0) {
          combinations[combinations.length] = combination;
        }
        return;
      }
      end = 0;
      while (end < array.length) {
        _generateCombinations(start - 1, array.slice(end + 1), combination.concat([array[end]]), combinations);
        end++;
      }
    };
    combinations = [];
    index = 0;
    while (index < array.length) {
      _generateCombinations(index, array, [], combinations);
      index++;
    }
    combinations.push(array);
    return combinations;
  };
  beforeEach(function() {
    this.addMatchers({
      toBeInstanceOf: function(className) {
        return this.actual instanceof Ext.ClassManager.get(className);
      }
    });
  });
  describe('when()', function() {
    var MockThirdPartyPromise, cancelCallback, deferred, failureCallback, progressCallback, successCallback;
    deferred = null;
    successCallback = failureCallback = progressCallback = cancelCallback = null;
    MockThirdPartyPromise = (function() {

      function MockThirdPartyPromise() {}

      MockThirdPartyPromise.prototype.then = function(successCallback, failureCallback) {
        this.successCallback = successCallback;
        this.failureCallback = failureCallback;
        switch (this.state) {
          case 'resolved':
            this.successCallback(this.value);
            break;
          case 'rejected':
            this.failureCallback(this.value);
        }
      };

      MockThirdPartyPromise.prototype.resolve = function(value) {
        this.value = value;
        this.state = 'resolved';
        if (this.successCallback != null) {
          this.successCallback(this.value);
        }
      };

      MockThirdPartyPromise.prototype.reject = function(value) {
        this.value = value;
        this.state = 'rejected';
        if (this.failureCallback != null) {
          this.failureCallback(this.value);
        }
      };

      return MockThirdPartyPromise;

    })();
    beforeEach(function() {
      deferred = Ext.create('Deft.promise.Deferred');
      successCallback = jasmine.createSpy('success callback');
      failureCallback = jasmine.createSpy('failure callback');
      progressCallback = jasmine.createSpy('progress callback');
      cancelCallback = jasmine.createSpy('cancel callback');
    });
    it('should return an immediately resolved Promise when a value specified', function() {
      var promise;
      promise = Deft.promise.Promise.when('expected value');
      promise.then({
        success: successCallback,
        failure: failureCallback,
        progress: progressCallback,
        cancel: cancelCallback
      });
      expect(promise).toBeInstanceOf('Deft.promise.Promise');
      expect(promise.getState()).toBe('resolved');
      expect(successCallback).toHaveBeenCalledWith('expected value');
      expect(failureCallback).not.toHaveBeenCalled();
      expect(progressCallback).not.toHaveBeenCalled();
      expect(cancelCallback).not.toHaveBeenCalled();
    });
    it('should return a new resolved Promise when a resolved Promise is specified', function() {
      var promise;
      deferred.resolve('expected value');
      promise = Deft.promise.Promise.when(deferred.getPromise());
      promise.then({
        success: successCallback,
        failure: failureCallback,
        progress: progressCallback,
        cancel: cancelCallback
      });
      expect(promise).toBeInstanceOf('Deft.promise.Promise');
      expect(promise).not.toBe(deferred.getPromise());
      expect(promise.getState()).toBe('resolved');
      expect(successCallback).toHaveBeenCalledWith('expected value');
      expect(failureCallback).not.toHaveBeenCalled();
      expect(progressCallback).not.toHaveBeenCalled();
      expect(cancelCallback).not.toHaveBeenCalled();
    });
    it('should return a new rejected Promise when a rejected Promise is specified', function() {
      var promise;
      deferred.reject('error message');
      promise = Deft.promise.Promise.when(deferred.getPromise());
      promise.then({
        success: successCallback,
        failure: failureCallback,
        progress: progressCallback,
        cancel: cancelCallback
      });
      expect(promise).toBeInstanceOf('Deft.promise.Promise');
      expect(promise).not.toBe(deferred.getPromise());
      expect(promise.getState()).toBe('rejected');
      expect(successCallback).not.toHaveBeenCalled();
      expect(failureCallback).toHaveBeenCalledWith('error message');
      expect(progressCallback).not.toHaveBeenCalled();
      expect(cancelCallback).not.toHaveBeenCalled();
    });
    it('should return a new pending (and immediately updated) Promise when a pending (and updated) Promise is specified', function() {
      var promise;
      deferred.update('progress');
      promise = Deft.promise.Promise.when(deferred.getPromise());
      promise.then({
        success: successCallback,
        failure: failureCallback,
        progress: progressCallback,
        cancel: cancelCallback
      });
      expect(promise).toBeInstanceOf('Deft.promise.Promise');
      expect(promise).not.toBe(deferred.getPromise());
      expect(promise.getState()).toBe('pending');
      expect(successCallback).not.toHaveBeenCalled();
      expect(failureCallback).not.toHaveBeenCalled();
      expect(progressCallback).toHaveBeenCalledWith('progress');
      expect(cancelCallback).not.toHaveBeenCalled();
    });
    it('should return a new cancelled Promise when a cancelled Promise specified', function() {
      var promise;
      deferred.cancel('reason');
      promise = Deft.promise.Promise.when(deferred.getPromise());
      promise.then({
        success: successCallback,
        failure: failureCallback,
        progress: progressCallback,
        cancel: cancelCallback
      });
      expect(promise).toBeInstanceOf('Deft.promise.Promise');
      expect(promise).not.toBe(deferred.getPromise());
      expect(promise.getState()).toBe('cancelled');
      expect(successCallback).not.toHaveBeenCalled();
      expect(failureCallback).not.toHaveBeenCalled();
      expect(progressCallback).not.toHaveBeenCalled();
      expect(cancelCallback).toHaveBeenCalledWith('reason');
    });
    it('should return a new pending Promise that resolves when the pending Promise specified is resolved', function() {
      var promise;
      promise = Deft.promise.Promise.when(deferred.getPromise());
      promise.then({
        success: successCallback,
        failure: failureCallback,
        progress: progressCallback,
        cancel: cancelCallback
      });
      expect(promise).toBeInstanceOf('Deft.promise.Promise');
      expect(promise).not.toBe(deferred.getPromise());
      expect(promise.getState()).toBe('pending');
      expect(successCallback).not.toHaveBeenCalled();
      expect(failureCallback).not.toHaveBeenCalled();
      expect(progressCallback).not.toHaveBeenCalled();
      expect(cancelCallback).not.toHaveBeenCalled();
      deferred.resolve('expected value');
      expect(promise.getState()).toBe('resolved');
      expect(successCallback).toHaveBeenCalledWith('expected value');
      expect(failureCallback).not.toHaveBeenCalled();
      expect(progressCallback).not.toHaveBeenCalled();
      expect(cancelCallback).not.toHaveBeenCalled();
    });
    it('should return a new pending Promise that rejects when the pending Promise specified is rejected', function() {
      var promise;
      promise = Deft.promise.Promise.when(deferred.getPromise());
      promise.then({
        success: successCallback,
        failure: failureCallback,
        progress: progressCallback,
        cancel: cancelCallback
      });
      expect(promise).toBeInstanceOf('Deft.promise.Promise');
      expect(promise).not.toBe(deferred.getPromise());
      expect(promise.getState()).toBe('pending');
      expect(successCallback).not.toHaveBeenCalled();
      expect(failureCallback).not.toHaveBeenCalled();
      expect(progressCallback).not.toHaveBeenCalled();
      expect(cancelCallback).not.toHaveBeenCalled();
      deferred.reject('error message');
      expect(promise.getState()).toBe('rejected');
      expect(successCallback).not.toHaveBeenCalled();
      expect(failureCallback).toHaveBeenCalledWith('error message');
      expect(progressCallback).not.toHaveBeenCalled();
      expect(cancelCallback).not.toHaveBeenCalled();
    });
    it('should return a new pending Promise that updates when the pending Promise specified is updated', function() {
      var promise;
      promise = Deft.promise.Promise.when(deferred.getPromise());
      promise.then({
        success: successCallback,
        failure: failureCallback,
        progress: progressCallback,
        cancel: cancelCallback
      });
      expect(promise).toBeInstanceOf('Deft.promise.Promise');
      expect(promise).not.toBe(deferred.getPromise());
      expect(promise.getState()).toBe('pending');
      expect(successCallback).not.toHaveBeenCalled();
      expect(failureCallback).not.toHaveBeenCalled();
      expect(progressCallback).not.toHaveBeenCalled();
      expect(cancelCallback).not.toHaveBeenCalled();
      deferred.update('progress');
      expect(promise.getState()).toBe('pending');
      expect(successCallback).not.toHaveBeenCalled();
      expect(failureCallback).not.toHaveBeenCalled();
      expect(progressCallback).toHaveBeenCalledWith('progress');
      expect(cancelCallback).not.toHaveBeenCalled();
    });
    it('should return a new pending Promise that cancels when the pending Promise specified is cancelled', function() {
      var promise;
      promise = Deft.promise.Promise.when(deferred.getPromise());
      promise.then({
        success: successCallback,
        failure: failureCallback,
        progress: progressCallback,
        cancel: cancelCallback
      });
      expect(promise).toBeInstanceOf('Deft.promise.Promise');
      expect(promise).not.toBe(deferred.getPromise());
      expect(promise.getState()).toBe('pending');
      expect(successCallback).not.toHaveBeenCalled();
      expect(failureCallback).not.toHaveBeenCalled();
      expect(progressCallback).not.toHaveBeenCalled();
      expect(cancelCallback).not.toHaveBeenCalled();
      deferred.cancel('reason');
      expect(promise.getState()).toBe('cancelled');
      expect(successCallback).not.toHaveBeenCalled();
      expect(failureCallback).not.toHaveBeenCalled();
      expect(progressCallback).not.toHaveBeenCalled();
      expect(cancelCallback).toHaveBeenCalledWith('reason');
    });
    it('should return a new resolved Promise when a resolved untrusted Promise is specified', function() {
      var mockThirdPartyPromise, promise;
      mockThirdPartyPromise = new MockThirdPartyPromise();
      mockThirdPartyPromise.resolve('expected value');
      promise = Deft.promise.Promise.when(mockThirdPartyPromise);
      promise.then({
        success: successCallback,
        failure: failureCallback,
        progress: progressCallback,
        cancel: cancelCallback
      });
      expect(promise).toBeInstanceOf('Deft.promise.Promise');
      expect(promise).not.toBe(mockThirdPartyPromise);
      expect(promise.getState()).toBe('resolved');
      expect(successCallback).toHaveBeenCalledWith('expected value');
      expect(failureCallback).not.toHaveBeenCalled();
      expect(progressCallback).not.toHaveBeenCalled();
      expect(cancelCallback).not.toHaveBeenCalled();
    });
    it('should return a new rejected Promise when a rejected untrusted Promise is specified', function() {
      var mockThirdPartyPromise, promise;
      mockThirdPartyPromise = new MockThirdPartyPromise();
      mockThirdPartyPromise.reject('error message');
      promise = Deft.promise.Promise.when(mockThirdPartyPromise);
      promise.then({
        success: successCallback,
        failure: failureCallback,
        progress: progressCallback,
        cancel: cancelCallback
      });
      expect(promise).toBeInstanceOf('Deft.promise.Promise');
      expect(promise).not.toBe(mockThirdPartyPromise);
      expect(promise.getState()).toBe('rejected');
      expect(successCallback).not.toHaveBeenCalled();
      expect(failureCallback).toHaveBeenCalledWith('error message');
      expect(progressCallback).not.toHaveBeenCalled();
      expect(cancelCallback).not.toHaveBeenCalled();
    });
    it('should return a new Promise that resolves when the specified untrusted Promise is resolved', function() {
      var mockThirdPartyPromise, promise;
      mockThirdPartyPromise = new MockThirdPartyPromise();
      promise = Deft.promise.Promise.when(mockThirdPartyPromise);
      promise.then({
        success: successCallback,
        failure: failureCallback,
        progress: progressCallback,
        cancel: cancelCallback
      });
      expect(promise).toBeInstanceOf('Deft.promise.Promise');
      expect(promise).not.toBe(mockThirdPartyPromise);
      expect(promise.getState()).toBe('pending');
      expect(successCallback).not.toHaveBeenCalled();
      expect(failureCallback).not.toHaveBeenCalled();
      expect(progressCallback).not.toHaveBeenCalled();
      expect(cancelCallback).not.toHaveBeenCalled();
      mockThirdPartyPromise.resolve('expected value');
      expect(promise.getState()).toBe('resolved');
      expect(successCallback).toHaveBeenCalledWith('expected value');
      expect(failureCallback).not.toHaveBeenCalled();
      expect(progressCallback).not.toHaveBeenCalled();
      expect(cancelCallback).not.toHaveBeenCalled();
    });
    return it('should return a new Promise that rejects when the specified untrusted Promise is rejected', function() {
      var mockThirdPartyPromise, promise;
      mockThirdPartyPromise = new MockThirdPartyPromise();
      promise = Deft.promise.Promise.when(mockThirdPartyPromise);
      promise.then({
        success: successCallback,
        failure: failureCallback,
        progress: progressCallback,
        cancel: cancelCallback
      });
      expect(promise).toBeInstanceOf('Deft.promise.Promise');
      expect(promise).not.toBe(mockThirdPartyPromise);
      expect(promise.getState()).toBe('pending');
      expect(successCallback).not.toHaveBeenCalled();
      expect(failureCallback).not.toHaveBeenCalled();
      expect(progressCallback).not.toHaveBeenCalled();
      expect(cancelCallback).not.toHaveBeenCalled();
      mockThirdPartyPromise.reject('error message');
      expect(promise.getState()).toBe('rejected');
      expect(successCallback).not.toHaveBeenCalled();
      expect(failureCallback).toHaveBeenCalledWith('error message');
      expect(progressCallback).not.toHaveBeenCalled();
      expect(cancelCallback).not.toHaveBeenCalled();
    });
  });
  describe('all()', function() {
    var cancelCallback, failureCallback, progressCallback, successCallback;
    successCallback = failureCallback = progressCallback = cancelCallback = null;
    beforeEach(function() {
      successCallback = jasmine.createSpy('success callback');
      failureCallback = jasmine.createSpy('failure callback');
      progressCallback = jasmine.createSpy('progress callback');
      cancelCallback = jasmine.createSpy('cancel callback');
    });
    describe('with an Array containing a single value', function() {
      var itShouldResolveForValue, value, values, _i, _len;
      itShouldResolveForValue = function(value) {
        it("should return an immediately resolved Promise when an Array containing '" + value + "' is specified", function() {
          var promise;
          promise = Deft.promise.Promise.all(['expected value']);
          promise.then({
            success: successCallback,
            failure: failureCallback,
            progress: progressCallback,
            cancel: cancelCallback
          });
          expect(promise).toBeInstanceOf('Deft.promise.Promise');
          expect(promise.getState()).toBe('resolved');
          expect(successCallback).toHaveBeenCalledWith(['expected value']);
          expect(failureCallback).not.toHaveBeenCalled();
          expect(progressCallback).not.toHaveBeenCalled();
          expect(cancelCallback).not.toHaveBeenCalled();
        });
      };
      values = [void 0, null, false, 0, 1, 'expected value', [], {}];
      for (_i = 0, _len = values.length; _i < _len; _i++) {
        value = values[_i];
        itShouldResolveForValue.call(this, value);
      }
    });
    describe('with an Array containing a single Deferred', function() {
      it('should return a resolved Promise when an Array containing a single resolved Deferred is specified', function() {
        var deferred, promise;
        deferred = Ext.create('Deft.promise.Deferred');
        deferred.resolve('expected value');
        promise = Deft.promise.Promise.all([deferred]);
        promise.then({
          success: successCallback,
          failure: failureCallback,
          progress: progressCallback,
          cancel: cancelCallback
        });
        expect(promise).toBeInstanceOf('Deft.promise.Promise');
        expect(promise.getState()).toBe('resolved');
        expect(successCallback).toHaveBeenCalledWith(['expected value']);
        expect(failureCallback).not.toHaveBeenCalled();
        expect(progressCallback).not.toHaveBeenCalled();
        expect(cancelCallback).not.toHaveBeenCalled();
      });
      it('should return a rejected Promise completed with the originating error when an Array containing a single rejected Deferred is specified', function() {
        var deferred, promise;
        deferred = Ext.create('Deft.promise.Deferred');
        deferred.reject('error message');
        promise = Deft.promise.Promise.all([deferred]);
        promise.then({
          success: successCallback,
          failure: failureCallback,
          progress: progressCallback,
          cancel: cancelCallback
        });
        expect(promise).toBeInstanceOf('Deft.promise.Promise');
        expect(promise.getState()).toBe('rejected');
        expect(successCallback).not.toHaveBeenCalled();
        expect(failureCallback).toHaveBeenCalledWith('error message');
        expect(progressCallback).not.toHaveBeenCalled();
        expect(cancelCallback).not.toHaveBeenCalled();
      });
      it('should return a pending (and immediately updated) Promise when an Array containing a single pending (and updated) Deferred is specified', function() {
        var deferred, promise;
        deferred = Ext.create('Deft.promise.Deferred');
        deferred.update('progress');
        promise = Deft.promise.Promise.all([deferred]);
        promise.then({
          success: successCallback,
          failure: failureCallback,
          progress: progressCallback,
          cancel: cancelCallback
        });
        expect(promise).toBeInstanceOf('Deft.promise.Promise');
        expect(promise.getState()).toBe('pending');
        expect(successCallback).not.toHaveBeenCalled();
        expect(failureCallback).not.toHaveBeenCalled();
        expect(progressCallback).toHaveBeenCalledWith('progress');
        expect(cancelCallback).not.toHaveBeenCalled();
      });
      it('should return a cancelled Promise completed with the originating reason when an Array containing a single cancelled Deferred is specified', function() {
        var deferred, promise;
        deferred = Ext.create('Deft.promise.Deferred');
        deferred.cancel('reason');
        promise = Deft.promise.Promise.all([deferred]);
        promise.then({
          success: successCallback,
          failure: failureCallback,
          progress: progressCallback,
          cancel: cancelCallback
        });
        expect(promise).toBeInstanceOf('Deft.promise.Promise');
        expect(promise.getState()).toBe('cancelled');
        expect(successCallback).not.toHaveBeenCalled();
        expect(failureCallback).not.toHaveBeenCalled();
        expect(progressCallback).not.toHaveBeenCalled();
        expect(cancelCallback).toHaveBeenCalledWith('reason');
      });
      it('should return a Promise that resolves when an Array containing a single Deferred is specified and that Deferred is resolved', function() {
        var deferred, promise;
        deferred = Ext.create('Deft.promise.Deferred');
        promise = Deft.promise.Promise.all([deferred]);
        promise.then({
          success: successCallback,
          failure: failureCallback,
          progress: progressCallback,
          cancel: cancelCallback
        });
        expect(promise).toBeInstanceOf('Deft.promise.Promise');
        expect(promise.getState()).toBe('pending');
        deferred.resolve('expected value');
        expect(promise.getState()).toBe('resolved');
        expect(successCallback).toHaveBeenCalledWith(['expected value']);
        expect(failureCallback).not.toHaveBeenCalled();
        expect(progressCallback).not.toHaveBeenCalled();
        expect(cancelCallback).not.toHaveBeenCalled();
      });
      it('should return a Promise that rejects when an Array containing a single Deferred is specified and that Deferred is rejected', function() {
        var deferred, promise;
        deferred = Ext.create('Deft.promise.Deferred');
        promise = Deft.promise.Promise.all([deferred]);
        promise.then({
          success: successCallback,
          failure: failureCallback,
          progress: progressCallback,
          cancel: cancelCallback
        });
        expect(promise).toBeInstanceOf('Deft.promise.Promise');
        expect(promise.getState()).toBe('pending');
        deferred.reject('error message');
        expect(promise.getState()).toBe('rejected');
        expect(successCallback).not.toHaveBeenCalled();
        expect(failureCallback).toHaveBeenCalledWith('error message');
        expect(progressCallback).not.toHaveBeenCalled();
        expect(cancelCallback).not.toHaveBeenCalled();
      });
      it('should return a Promise that updates when an Array containing a single Deferred is specified and that Deferred is updated', function() {
        var deferred, promise;
        deferred = Ext.create('Deft.promise.Deferred');
        promise = Deft.promise.Promise.all([deferred]);
        promise.then({
          success: successCallback,
          failure: failureCallback,
          progress: progressCallback,
          cancel: cancelCallback
        });
        expect(promise).toBeInstanceOf('Deft.promise.Promise');
        expect(promise.getState()).toBe('pending');
        deferred.update('progress');
        expect(promise.getState()).toBe('pending');
        expect(successCallback).not.toHaveBeenCalled();
        expect(failureCallback).not.toHaveBeenCalled();
        expect(progressCallback).toHaveBeenCalledWith('progress');
        expect(cancelCallback).not.toHaveBeenCalled();
      });
      return it('should return a Promise that cancels when an Array containing a single Deferred is specified and that Deferred is cancelled', function() {
        var deferred, promise;
        deferred = Ext.create('Deft.promise.Deferred');
        promise = Deft.promise.Promise.all([deferred]);
        promise.then({
          success: successCallback,
          failure: failureCallback,
          progress: progressCallback,
          cancel: cancelCallback
        });
        expect(promise).toBeInstanceOf('Deft.promise.Promise');
        expect(promise.getState()).toBe('pending');
        deferred.cancel('reason');
        expect(promise.getState()).toBe('cancelled');
        expect(successCallback).not.toHaveBeenCalled();
        expect(failureCallback).not.toHaveBeenCalled();
        expect(progressCallback).not.toHaveBeenCalled();
        expect(cancelCallback).toHaveBeenCalledWith('reason');
      });
    });
    describe('with an Array containing a single Promise', function() {
      it('should return a resolved Promise when an Array containing a single resolved Promise is specified', function() {
        var deferred, promise;
        deferred = Ext.create('Deft.promise.Deferred');
        deferred.resolve('expected value');
        promise = Deft.promise.Promise.all([deferred.getPromise()]);
        promise.then({
          success: successCallback,
          failure: failureCallback,
          progress: progressCallback,
          cancel: cancelCallback
        });
        expect(promise).toBeInstanceOf('Deft.promise.Promise');
        expect(promise.getState()).toBe('resolved');
        expect(successCallback).toHaveBeenCalledWith(['expected value']);
        expect(failureCallback).not.toHaveBeenCalled();
        expect(progressCallback).not.toHaveBeenCalled();
        expect(cancelCallback).not.toHaveBeenCalled();
      });
      it('should return a rejected Promise completed with the originating error when an Array containing a single rejected Promise is specified', function() {
        var deferred, promise;
        deferred = Ext.create('Deft.promise.Deferred');
        deferred.reject('error message');
        promise = Deft.promise.Promise.all([deferred.getPromise()]);
        promise.then({
          success: successCallback,
          failure: failureCallback,
          progress: progressCallback,
          cancel: cancelCallback
        });
        expect(promise).toBeInstanceOf('Deft.promise.Promise');
        expect(promise.getState()).toBe('rejected');
        expect(successCallback).not.toHaveBeenCalled();
        expect(failureCallback).toHaveBeenCalledWith('error message');
        expect(progressCallback).not.toHaveBeenCalled();
        expect(cancelCallback).not.toHaveBeenCalled();
      });
      it('should return a pending (and immediately updated) Promise when an Array containing a single pending (and updated) Promise is specified', function() {
        var deferred, promise;
        deferred = Ext.create('Deft.promise.Deferred');
        deferred.update('progress');
        promise = Deft.promise.Promise.all([deferred.getPromise()]);
        promise.then({
          success: successCallback,
          failure: failureCallback,
          progress: progressCallback,
          cancel: cancelCallback
        });
        expect(promise).toBeInstanceOf('Deft.promise.Promise');
        expect(promise.getState()).toBe('pending');
        expect(successCallback).not.toHaveBeenCalled();
        expect(failureCallback).not.toHaveBeenCalled();
        expect(progressCallback).toHaveBeenCalledWith('progress');
        expect(cancelCallback).not.toHaveBeenCalled();
      });
      it('should return a cancelled Promise completed with the originating reason when an Array containing a single cancelled Promise is specified', function() {
        var deferred, promise;
        deferred = Ext.create('Deft.promise.Deferred');
        deferred.cancel('reason');
        promise = Deft.promise.Promise.all([deferred.getPromise()]);
        promise.then({
          success: successCallback,
          failure: failureCallback,
          progress: progressCallback,
          cancel: cancelCallback
        });
        expect(promise).toBeInstanceOf('Deft.promise.Promise');
        expect(promise.getState()).toBe('cancelled');
        expect(successCallback).not.toHaveBeenCalled();
        expect(failureCallback).not.toHaveBeenCalled();
        expect(progressCallback).not.toHaveBeenCalled();
        expect(cancelCallback).toHaveBeenCalledWith('reason');
      });
      it('should return a Promise that resolves when an Array containing a single Promise is specified and that Promise is resolved', function() {
        var deferred, promise;
        deferred = Ext.create('Deft.promise.Deferred');
        promise = Deft.promise.Promise.all([deferred.getPromise()]);
        promise.then({
          success: successCallback,
          failure: failureCallback,
          progress: progressCallback,
          cancel: cancelCallback
        });
        expect(promise).toBeInstanceOf('Deft.promise.Promise');
        expect(promise.getState()).toBe('pending');
        deferred.resolve('expected value');
        expect(promise.getState()).toBe('resolved');
        expect(successCallback).toHaveBeenCalledWith(['expected value']);
        expect(failureCallback).not.toHaveBeenCalled();
        expect(progressCallback).not.toHaveBeenCalled();
        expect(cancelCallback).not.toHaveBeenCalled();
      });
      it('should return a Promise that rejects when an Array containing a single Promise is specified and that Promise is rejected', function() {
        var deferred, promise;
        deferred = Ext.create('Deft.promise.Deferred');
        promise = Deft.promise.Promise.all([deferred.getPromise()]);
        promise.then({
          success: successCallback,
          failure: failureCallback,
          progress: progressCallback,
          cancel: cancelCallback
        });
        expect(promise).toBeInstanceOf('Deft.promise.Promise');
        expect(promise.getState()).toBe('pending');
        deferred.reject('error message');
        expect(promise.getState()).toBe('rejected');
        expect(successCallback).not.toHaveBeenCalled();
        expect(failureCallback).toHaveBeenCalledWith('error message');
        expect(progressCallback).not.toHaveBeenCalled();
        expect(cancelCallback).not.toHaveBeenCalled();
      });
      it('should return a Promise that updates when an Array containing a single Promise is specified and that Promise is updated', function() {
        var deferred, promise;
        deferred = Ext.create('Deft.promise.Deferred');
        promise = Deft.promise.Promise.all([deferred.getPromise()]);
        promise.then({
          success: successCallback,
          failure: failureCallback,
          progress: progressCallback,
          cancel: cancelCallback
        });
        expect(promise).toBeInstanceOf('Deft.promise.Promise');
        expect(promise.getState()).toBe('pending');
        deferred.update('progress');
        expect(promise.getState()).toBe('pending');
        expect(successCallback).not.toHaveBeenCalled();
        expect(failureCallback).not.toHaveBeenCalled();
        expect(progressCallback).toHaveBeenCalledWith('progress');
        expect(cancelCallback).not.toHaveBeenCalled();
      });
      return it('should return a Promise that cancels when an Array containing a single Promise is specified and that Promise is cancelled', function() {
        var deferred, promise;
        deferred = Ext.create('Deft.promise.Deferred');
        promise = Deft.promise.Promise.all([deferred.getPromise()]);
        promise.then({
          success: successCallback,
          failure: failureCallback,
          progress: progressCallback,
          cancel: cancelCallback
        });
        expect(promise).toBeInstanceOf('Deft.promise.Promise');
        expect(promise.getState()).toBe('pending');
        deferred.cancel('reason');
        expect(promise.getState()).toBe('cancelled');
        expect(successCallback).not.toHaveBeenCalled();
        expect(failureCallback).not.toHaveBeenCalled();
        expect(progressCallback).not.toHaveBeenCalled();
        expect(cancelCallback).toHaveBeenCalledWith('reason');
      });
    });
    describe('with multiple items specified', function() {
      var getInputParameters, getOutputParameters;
      getInputParameters = function(parameters) {
        var inputs, parameter, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = parameters.length; _i < _len; _i++) {
          parameter = parameters[_i];
          _results.push(inputs = parameter.input);
        }
        return _results;
      };
      getOutputParameters = function(parameters) {
        var outputs, parameter, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = parameters.length; _i < _len; _i++) {
          parameter = parameters[_i];
          _results.push(outputs = parameter.output);
        }
        return _results;
      };
      it('should return a resolved Promise when an Array containing any combination of values, resolved Deferreds and/or resolved Promises is specified', function() {
        var combination, deferredB, deferredC, parameters, permutation, promise, promiseC, _i, _j, _len, _len1, _ref, _ref1;
        deferredB = Ext.create('Deft.promise.Deferred');
        deferredB.resolve('B');
        deferredC = Ext.create('Deft.promise.Deferred');
        deferredC.resolve('C');
        promiseC = deferredC.getPromise();
        parameters = [
          {
            input: 'A',
            output: 'A'
          }, {
            input: deferredB,
            output: 'B'
          }, {
            input: promiseC,
            output: 'C'
          }
        ];
        _ref = generateCombinations(parameters);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination);
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            promise = Deft.promise.Promise.all(getInputParameters(permutation));
            promise.then({
              success: successCallback,
              failure: failureCallback,
              progress: progressCallback,
              cancel: cancelCallback
            });
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('resolved');
            expect(successCallback).toHaveBeenCalledWith(getOutputParameters(permutation));
            expect(failureCallback).not.toHaveBeenCalled();
            expect(progressCallback).not.toHaveBeenCalled();
            expect(cancelCallback).not.toHaveBeenCalled();
            successCallback.reset();
            failureCallback.reset();
            progressCallback.reset();
            cancelCallback.reset();
          }
        }
      });
      it('should return a rejected Promise when an Array containing any combination of values, resolved or pending Deferreds, and/or resolved or pending Promises, and a rejected Deferred or Promise is specified', function() {
        var combination, deferredB, deferredC, parameters, pendingDeferred, permutation, promise, promiseC, rejectedDeferred, rejectedDeferredParameter, rejectedPromiseParameter, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
        deferredB = Ext.create('Deft.promise.Deferred');
        deferredB.resolve('B');
        deferredC = Ext.create('Deft.promise.Deferred');
        deferredC.resolve('C');
        promiseC = deferredC.getPromise();
        pendingDeferred = Ext.create('Deft.promise.Deferred');
        parameters = [
          {
            input: 'A',
            output: 'A'
          }, {
            input: deferredB,
            output: 'B'
          }, {
            input: promiseC,
            output: 'C'
          }, {
            input: pendingDeferred
          }, {
            input: pendingDeferred.getPromise()
          }
        ];
        rejectedDeferred = Ext.create('Deft.promise.Deferred');
        rejectedDeferred.reject('error message');
        rejectedDeferredParameter = {
          input: rejectedDeferred,
          output: 'error message'
        };
        _ref = generateCombinations(parameters);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination.concat(rejectedDeferredParameter));
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            promise = Deft.promise.Promise.all(getInputParameters(permutation));
            promise.then({
              success: successCallback,
              failure: failureCallback,
              progress: progressCallback,
              cancel: cancelCallback
            });
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('rejected');
            expect(successCallback).not.toHaveBeenCalled();
            expect(failureCallback).toHaveBeenCalledWith('error message');
            expect(progressCallback).not.toHaveBeenCalled();
            expect(cancelCallback).not.toHaveBeenCalled();
            successCallback.reset();
            failureCallback.reset();
            progressCallback.reset();
            cancelCallback.reset();
          }
        }
        rejectedPromiseParameter = {
          input: rejectedDeferred.getPromise(),
          output: 'error message'
        };
        _ref2 = generateCombinations(parameters);
        _results = [];
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          combination = _ref2[_k];
          _results.push((function() {
            var _l, _len3, _ref3, _results1;
            _ref3 = generatePermutations(combination.concat(rejectedPromiseParameter));
            _results1 = [];
            for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
              permutation = _ref3[_l];
              promise = Deft.promise.Promise.all(getInputParameters(permutation));
              promise.then({
                success: successCallback,
                failure: failureCallback,
                progress: progressCallback,
                cancel: cancelCallback
              });
              expect(promise).toBeInstanceOf('Deft.promise.Promise');
              expect(promise.getState()).toBe('rejected');
              expect(successCallback).not.toHaveBeenCalled();
              expect(failureCallback).toHaveBeenCalledWith('error message');
              expect(progressCallback).not.toHaveBeenCalled();
              expect(cancelCallback).not.toHaveBeenCalled();
              successCallback.reset();
              failureCallback.reset();
              progressCallback.reset();
              _results1.push(cancelCallback.reset());
            }
            return _results1;
          })());
        }
        return _results;
      });
      it('should return a pending (and immediately updated) Promise when an Array containing any combination of values, resolved or pending Deferreds, and/or resolved or pending Promises, and pending (and updated) Deferred or Promise is specified', function() {
        var combination, deferredB, deferredC, parameters, pendingDeferred, permutation, promise, promiseC, updatedDeferred, updatedDeferredParameter, updatedPromiseParameter, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
        deferredB = Ext.create('Deft.promise.Deferred');
        deferredB.resolve('B');
        deferredC = Ext.create('Deft.promise.Deferred');
        deferredC.resolve('C');
        promiseC = deferredC.getPromise();
        pendingDeferred = Ext.create('Deft.promise.Deferred');
        parameters = [
          {
            input: 'A',
            output: 'A'
          }, {
            input: deferredB,
            output: 'B'
          }, {
            input: promiseC,
            output: 'C'
          }, {
            input: pendingDeferred
          }, {
            input: pendingDeferred.getPromise()
          }
        ];
        updatedDeferred = Ext.create('Deft.promise.Deferred');
        updatedDeferred.update('progress');
        updatedDeferredParameter = {
          input: updatedDeferred,
          output: 'progress'
        };
        _ref = generateCombinations(parameters);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination.concat(updatedDeferredParameter));
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            promise = Deft.promise.Promise.all(getInputParameters(permutation));
            promise.then({
              success: successCallback,
              failure: failureCallback,
              progress: progressCallback,
              cancel: cancelCallback
            });
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('pending');
            expect(successCallback).not.toHaveBeenCalled();
            expect(failureCallback).not.toHaveBeenCalled();
            expect(progressCallback).toHaveBeenCalledWith('progress');
            expect(cancelCallback).not.toHaveBeenCalled();
            successCallback.reset();
            failureCallback.reset();
            progressCallback.reset();
            cancelCallback.reset();
          }
        }
        updatedPromiseParameter = {
          input: updatedDeferred.getPromise(),
          output: 'progress'
        };
        _ref2 = generateCombinations(parameters);
        _results = [];
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          combination = _ref2[_k];
          _results.push((function() {
            var _l, _len3, _ref3, _results1;
            _ref3 = generatePermutations(combination.concat(updatedPromiseParameter));
            _results1 = [];
            for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
              permutation = _ref3[_l];
              promise = Deft.promise.Promise.all(getInputParameters(permutation));
              promise.then({
                success: successCallback,
                failure: failureCallback,
                progress: progressCallback,
                cancel: cancelCallback
              });
              expect(promise).toBeInstanceOf('Deft.promise.Promise');
              expect(promise.getState()).toBe('pending');
              expect(successCallback).not.toHaveBeenCalled();
              expect(failureCallback).not.toHaveBeenCalled();
              expect(progressCallback).toHaveBeenCalledWith('progress');
              expect(cancelCallback).not.toHaveBeenCalled();
              successCallback.reset();
              failureCallback.reset();
              progressCallback.reset();
              _results1.push(cancelCallback.reset());
            }
            return _results1;
          })());
        }
        return _results;
      });
      it('should return a cancelled Promise when an Array containing any combination of values, resolved or pending Deferreds, and/or resolved or pending Promises, and a cancelled Deferred or Promise is specified', function() {
        var cancelledDeferred, cancelledDeferredParameter, cancelledPromiseParameter, combination, deferredB, deferredC, parameters, pendingDeferred, permutation, promise, promiseC, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
        deferredB = Ext.create('Deft.promise.Deferred');
        deferredB.resolve('B');
        deferredC = Ext.create('Deft.promise.Deferred');
        deferredC.resolve('C');
        promiseC = deferredC.getPromise();
        pendingDeferred = Ext.create('Deft.promise.Deferred');
        parameters = [
          {
            input: 'A',
            output: 'A'
          }, {
            input: deferredB,
            output: 'B'
          }, {
            input: promiseC,
            output: 'C'
          }, {
            input: pendingDeferred
          }, {
            input: pendingDeferred.getPromise()
          }
        ];
        cancelledDeferred = Ext.create('Deft.promise.Deferred');
        cancelledDeferred.cancel('reason');
        cancelledDeferredParameter = {
          input: cancelledDeferred,
          output: 'reason'
        };
        _ref = generateCombinations(parameters);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination.concat(cancelledDeferredParameter));
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            promise = Deft.promise.Promise.all(getInputParameters(permutation));
            promise.then({
              success: successCallback,
              failure: failureCallback,
              progress: progressCallback,
              cancel: cancelCallback
            });
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('cancelled');
            expect(successCallback).not.toHaveBeenCalled();
            expect(failureCallback).not.toHaveBeenCalled();
            expect(progressCallback).not.toHaveBeenCalled();
            expect(cancelCallback).toHaveBeenCalledWith('reason');
            successCallback.reset();
            failureCallback.reset();
            progressCallback.reset();
            cancelCallback.reset();
          }
        }
        cancelledPromiseParameter = {
          input: cancelledDeferred.getPromise(),
          output: 'reason'
        };
        _ref2 = generateCombinations(parameters);
        _results = [];
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          combination = _ref2[_k];
          _results.push((function() {
            var _l, _len3, _ref3, _results1;
            _ref3 = generatePermutations(combination.concat(cancelledPromiseParameter));
            _results1 = [];
            for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
              permutation = _ref3[_l];
              promise = Deft.promise.Promise.all(getInputParameters(permutation));
              promise.then({
                success: successCallback,
                failure: failureCallback,
                progress: progressCallback,
                cancel: cancelCallback
              });
              expect(promise).toBeInstanceOf('Deft.promise.Promise');
              expect(promise.getState()).toBe('cancelled');
              expect(successCallback).not.toHaveBeenCalled();
              expect(failureCallback).not.toHaveBeenCalled();
              expect(progressCallback).not.toHaveBeenCalled();
              expect(cancelCallback).toHaveBeenCalledWith('reason');
              successCallback.reset();
              failureCallback.reset();
              progressCallback.reset();
              _results1.push(cancelCallback.reset());
            }
            return _results1;
          })());
        }
        return _results;
      });
      it('should return a resolved Promise when an Array containing any combination of values, resolved Deferreds and/or resolved Promises, and a pending Deferred or Promise is specified, and that pending Deferred or Promise is resolved', function() {
        var combination, deferredB, deferredC, parameters, pendingDeferred, pendingDeferredParameter, pendingPromiseParameter, permutation, placeholder, promise, promiseC, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
        deferredB = Ext.create('Deft.promise.Deferred');
        deferredB.resolve('B');
        deferredC = Ext.create('Deft.promise.Deferred');
        deferredC.resolve('C');
        promiseC = deferredC.getPromise();
        parameters = [
          {
            input: 'A',
            output: 'A'
          }, {
            input: deferredB,
            output: 'B'
          }, {
            input: promiseC,
            output: 'C'
          }
        ];
        placeholder = {};
        _ref = generateCombinations(parameters);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination.concat(placeholder));
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            pendingDeferred = Ext.create('Deft.promise.Deferred');
            pendingDeferredParameter = {
              input: pendingDeferred,
              output: 'expected value'
            };
            permutation[Ext.Array.indexOf(permutation, placeholder)] = pendingDeferredParameter;
            promise = Deft.promise.Promise.all(getInputParameters(permutation));
            promise.then({
              success: successCallback,
              failure: failureCallback,
              progress: progressCallback,
              cancel: cancelCallback
            });
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('pending');
            expect(successCallback).not.toHaveBeenCalled();
            expect(failureCallback).not.toHaveBeenCalled();
            expect(progressCallback).not.toHaveBeenCalled();
            expect(cancelCallback).not.toHaveBeenCalled();
            successCallback.reset();
            failureCallback.reset();
            progressCallback.reset();
            cancelCallback.reset();
            pendingDeferred.resolve('expected value');
            expect(promise.getState()).toBe('resolved');
            expect(successCallback).toHaveBeenCalledWith(getOutputParameters(permutation));
            expect(failureCallback).not.toHaveBeenCalled();
            expect(progressCallback).not.toHaveBeenCalled();
            expect(cancelCallback).not.toHaveBeenCalled();
            successCallback.reset();
            failureCallback.reset();
            progressCallback.reset();
            cancelCallback.reset();
          }
        }
        _ref2 = generateCombinations(parameters);
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          combination = _ref2[_k];
          _ref3 = generatePermutations(combination.concat(placeholder));
          for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
            permutation = _ref3[_l];
            pendingDeferred = Ext.create('Deft.promise.Deferred');
            pendingPromiseParameter = {
              input: pendingDeferred.getPromise(),
              output: 'expected value'
            };
            permutation[Ext.Array.indexOf(permutation, placeholder)] = pendingPromiseParameter;
            promise = Deft.promise.Promise.all(getInputParameters(permutation));
            promise.then({
              success: successCallback,
              failure: failureCallback,
              progress: progressCallback,
              cancel: cancelCallback
            });
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('pending');
            expect(successCallback).not.toHaveBeenCalled();
            expect(failureCallback).not.toHaveBeenCalled();
            expect(progressCallback).not.toHaveBeenCalled();
            expect(cancelCallback).not.toHaveBeenCalled();
            successCallback.reset();
            failureCallback.reset();
            progressCallback.reset();
            cancelCallback.reset();
            pendingDeferred.resolve('expected value');
            expect(promise.getState()).toBe('resolved');
            expect(successCallback).toHaveBeenCalledWith(getOutputParameters(permutation));
            expect(failureCallback).not.toHaveBeenCalled();
            expect(progressCallback).not.toHaveBeenCalled();
            expect(cancelCallback).not.toHaveBeenCalled();
            successCallback.reset();
            failureCallback.reset();
            progressCallback.reset();
            cancelCallback.reset();
          }
        }
      });
      it('should return a rejected Promise when an Array containing any combination of values, resolved Deferreds and/or resolved Promises, and a pending Deferred or Promise is specified, and that pending Deferred or Promise is rejected', function() {
        var combination, deferredB, deferredC, parameters, pendingDeferred, pendingDeferredParameter, pendingPromiseParameter, permutation, placeholder, promise, promiseC, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
        deferredB = Ext.create('Deft.promise.Deferred');
        deferredB.resolve('B');
        deferredC = Ext.create('Deft.promise.Deferred');
        deferredC.resolve('C');
        promiseC = deferredC.getPromise();
        parameters = [
          {
            input: 'A',
            output: 'A'
          }, {
            input: deferredB,
            output: 'B'
          }, {
            input: promiseC,
            output: 'C'
          }
        ];
        placeholder = {};
        _ref = generateCombinations(parameters);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination.concat(placeholder));
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            pendingDeferred = Ext.create('Deft.promise.Deferred');
            pendingDeferredParameter = {
              input: pendingDeferred,
              output: 'error message'
            };
            permutation[Ext.Array.indexOf(permutation, placeholder)] = pendingDeferredParameter;
            promise = Deft.promise.Promise.all(getInputParameters(permutation));
            promise.then({
              success: successCallback,
              failure: failureCallback,
              progress: progressCallback,
              cancel: cancelCallback
            });
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('pending');
            expect(successCallback).not.toHaveBeenCalled();
            expect(failureCallback).not.toHaveBeenCalled();
            expect(progressCallback).not.toHaveBeenCalled();
            expect(cancelCallback).not.toHaveBeenCalled();
            successCallback.reset();
            failureCallback.reset();
            progressCallback.reset();
            cancelCallback.reset();
            pendingDeferred.reject('error message');
            expect(promise.getState()).toBe('rejected');
            expect(successCallback).not.toHaveBeenCalled();
            expect(failureCallback).toHaveBeenCalledWith('error message');
            expect(progressCallback).not.toHaveBeenCalled();
            expect(cancelCallback).not.toHaveBeenCalled();
            successCallback.reset();
            failureCallback.reset();
            progressCallback.reset();
            cancelCallback.reset();
          }
        }
        _ref2 = generateCombinations(parameters);
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          combination = _ref2[_k];
          _ref3 = generatePermutations(combination.concat(placeholder));
          for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
            permutation = _ref3[_l];
            pendingDeferred = Ext.create('Deft.promise.Deferred');
            pendingPromiseParameter = {
              input: pendingDeferred.getPromise(),
              output: 'error message'
            };
            permutation[Ext.Array.indexOf(permutation, placeholder)] = pendingPromiseParameter;
            promise = Deft.promise.Promise.all(getInputParameters(permutation));
            promise.then({
              success: successCallback,
              failure: failureCallback,
              progress: progressCallback,
              cancel: cancelCallback
            });
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('pending');
            expect(successCallback).not.toHaveBeenCalled();
            expect(failureCallback).not.toHaveBeenCalled();
            expect(progressCallback).not.toHaveBeenCalled();
            expect(cancelCallback).not.toHaveBeenCalled();
            successCallback.reset();
            failureCallback.reset();
            progressCallback.reset();
            cancelCallback.reset();
            pendingDeferred.reject('error message');
            expect(promise.getState()).toBe('rejected');
            expect(successCallback).not.toHaveBeenCalled();
            expect(failureCallback).toHaveBeenCalledWith('error message');
            expect(progressCallback).not.toHaveBeenCalled();
            expect(cancelCallback).not.toHaveBeenCalled();
            successCallback.reset();
            failureCallback.reset();
            progressCallback.reset();
            cancelCallback.reset();
          }
        }
      });
      it('should return a pending (and later updated) when an Array containing any combination of values, resolved Deferreds and/or resolved Promises, and a pending Deferred or Promise is specified, and that pending Deferred is updated', function() {
        var combination, deferredB, deferredC, parameters, pendingDeferred, pendingDeferredParameter, pendingPromiseParameter, permutation, placeholder, promise, promiseC, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
        deferredB = Ext.create('Deft.promise.Deferred');
        deferredB.resolve('B');
        deferredC = Ext.create('Deft.promise.Deferred');
        deferredC.resolve('C');
        promiseC = deferredC.getPromise();
        parameters = [
          {
            input: 'A',
            output: 'A'
          }, {
            input: deferredB,
            output: 'B'
          }, {
            input: promiseC,
            output: 'C'
          }
        ];
        placeholder = {};
        _ref = generateCombinations(parameters);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination.concat(placeholder));
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            pendingDeferred = Ext.create('Deft.promise.Deferred');
            pendingDeferredParameter = {
              input: pendingDeferred,
              output: 'error message'
            };
            permutation[Ext.Array.indexOf(permutation, placeholder)] = pendingDeferredParameter;
            promise = Deft.promise.Promise.all(getInputParameters(permutation));
            promise.then({
              success: successCallback,
              failure: failureCallback,
              progress: progressCallback,
              cancel: cancelCallback
            });
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('pending');
            expect(successCallback).not.toHaveBeenCalled();
            expect(failureCallback).not.toHaveBeenCalled();
            expect(progressCallback).not.toHaveBeenCalled();
            expect(cancelCallback).not.toHaveBeenCalled();
            successCallback.reset();
            failureCallback.reset();
            progressCallback.reset();
            cancelCallback.reset();
            pendingDeferred.update('progress');
            expect(promise.getState()).toBe('pending');
            expect(successCallback).not.toHaveBeenCalled();
            expect(failureCallback).not.toHaveBeenCalled();
            expect(progressCallback).toHaveBeenCalledWith('progress');
            expect(cancelCallback).not.toHaveBeenCalled();
            successCallback.reset();
            failureCallback.reset();
            progressCallback.reset();
            cancelCallback.reset();
          }
        }
        _ref2 = generateCombinations(parameters);
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          combination = _ref2[_k];
          _ref3 = generatePermutations(combination.concat(placeholder));
          for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
            permutation = _ref3[_l];
            pendingDeferred = Ext.create('Deft.promise.Deferred');
            pendingPromiseParameter = {
              input: pendingDeferred.getPromise(),
              output: 'error message'
            };
            permutation[Ext.Array.indexOf(permutation, placeholder)] = pendingPromiseParameter;
            promise = Deft.promise.Promise.all(getInputParameters(permutation));
            promise.then({
              success: successCallback,
              failure: failureCallback,
              progress: progressCallback,
              cancel: cancelCallback
            });
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('pending');
            expect(successCallback).not.toHaveBeenCalled();
            expect(failureCallback).not.toHaveBeenCalled();
            expect(progressCallback).not.toHaveBeenCalled();
            expect(cancelCallback).not.toHaveBeenCalled();
            successCallback.reset();
            failureCallback.reset();
            progressCallback.reset();
            cancelCallback.reset();
            pendingDeferred.update('progress');
            expect(promise.getState()).toBe('pending');
            expect(successCallback).not.toHaveBeenCalled();
            expect(failureCallback).not.toHaveBeenCalled();
            expect(progressCallback).toHaveBeenCalledWith('progress');
            expect(cancelCallback).not.toHaveBeenCalled();
            successCallback.reset();
            failureCallback.reset();
            progressCallback.reset();
            cancelCallback.reset();
          }
        }
      });
      it('should return a cancelled Promise when an Array containing any combination of values, resolved Deferreds and/or resolved Promises, and a pending Deferred or Promise is specified, and that pending Deferred or Promise is cancelled', function() {
        var combination, deferredB, deferredC, parameters, pendingDeferred, pendingDeferredParameter, pendingPromiseParameter, permutation, placeholder, promise, promiseC, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
        deferredB = Ext.create('Deft.promise.Deferred');
        deferredB.resolve('B');
        deferredC = Ext.create('Deft.promise.Deferred');
        deferredC.resolve('C');
        promiseC = deferredC.getPromise();
        parameters = [
          {
            input: 'A',
            output: 'A'
          }, {
            input: deferredB,
            output: 'B'
          }, {
            input: promiseC,
            output: 'C'
          }
        ];
        placeholder = {};
        _ref = generateCombinations(parameters);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination.concat(placeholder));
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            pendingDeferred = Ext.create('Deft.promise.Deferred');
            pendingDeferredParameter = {
              input: pendingDeferred,
              output: 'reason'
            };
            permutation[Ext.Array.indexOf(permutation, placeholder)] = pendingDeferredParameter;
            promise = Deft.promise.Promise.all(getInputParameters(permutation));
            promise.then({
              success: successCallback,
              failure: failureCallback,
              progress: progressCallback,
              cancel: cancelCallback
            });
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('pending');
            expect(successCallback).not.toHaveBeenCalled();
            expect(failureCallback).not.toHaveBeenCalled();
            expect(progressCallback).not.toHaveBeenCalled();
            expect(cancelCallback).not.toHaveBeenCalled();
            successCallback.reset();
            failureCallback.reset();
            progressCallback.reset();
            cancelCallback.reset();
            pendingDeferred.cancel('reason');
            expect(promise.getState()).toBe('cancelled');
            expect(successCallback).not.toHaveBeenCalled();
            expect(failureCallback).not.toHaveBeenCalled();
            expect(progressCallback).not.toHaveBeenCalled();
            expect(cancelCallback).toHaveBeenCalledWith('reason');
            successCallback.reset();
            failureCallback.reset();
            progressCallback.reset();
            cancelCallback.reset();
          }
        }
        _ref2 = generateCombinations(parameters);
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          combination = _ref2[_k];
          _ref3 = generatePermutations(combination.concat(placeholder));
          for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
            permutation = _ref3[_l];
            pendingDeferred = Ext.create('Deft.promise.Deferred');
            pendingPromiseParameter = {
              input: pendingDeferred.getPromise(),
              output: 'error message'
            };
            permutation[Ext.Array.indexOf(permutation, placeholder)] = pendingPromiseParameter;
            promise = Deft.promise.Promise.all(getInputParameters(permutation));
            promise.then({
              success: successCallback,
              failure: failureCallback,
              progress: progressCallback,
              cancel: cancelCallback
            });
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('pending');
            expect(successCallback).not.toHaveBeenCalled();
            expect(failureCallback).not.toHaveBeenCalled();
            expect(progressCallback).not.toHaveBeenCalled();
            expect(cancelCallback).not.toHaveBeenCalled();
            successCallback.reset();
            failureCallback.reset();
            progressCallback.reset();
            cancelCallback.reset();
            pendingDeferred.cancel('reason');
            expect(promise.getState()).toBe('cancelled');
            expect(successCallback).not.toHaveBeenCalled();
            expect(failureCallback).not.toHaveBeenCalled();
            expect(progressCallback).not.toHaveBeenCalled();
            expect(cancelCallback).toHaveBeenCalledWith('reason');
            successCallback.reset();
            failureCallback.reset();
            progressCallback.reset();
            cancelCallback.reset();
          }
        }
      });
    });
  });
  describe('any()', function() {
    var cancelCallback, failureCallback, progressCallback, successCallback;
    successCallback = failureCallback = progressCallback = cancelCallback = null;
    return beforeEach(function() {
      successCallback = jasmine.createSpy('success callback');
      failureCallback = jasmine.createSpy('failure callback');
      progressCallback = jasmine.createSpy('progress callback');
      cancelCallback = jasmine.createSpy('cancel callback');
    });
  });
  describe('memoize()', function() {
    var cancelCallback, createSpecsForScope, failureCallback, fibonacci, progressCallback, successCallback;
    successCallback = failureCallback = progressCallback = cancelCallback = null;
    fibonacci = function(n) {
      if (n < 2) {
        return n;
      } else {
        return fibonacci(n - 1) + fibonacci(n - 2);
      }
    };
    createSpecsForScope = function(expectedScope) {
      var createTargetFunction;
      createTargetFunction = function() {
        return jasmine.createSpy('target function').andCallFake(function() {
          if (expectedScope != null) {
            expect(this).toBe(expectedScope);
          } else {
            expect(this).toBe(window);
          }
          return fibonacci.apply(this, arguments);
        });
      };
      it('should return a new function that wraps the specified function and caches the results for previously processed inputs, and returns a resolved Promise when the input is a value', function() {
        var memoFunction, promise, result, targetFunction;
        targetFunction = createTargetFunction();
        memoFunction = Deft.promise.Promise.memoize(targetFunction, expectedScope);
        result = null;
        promise = memoFunction(12);
        promise.then({
          success: function(value) {
            return result = value;
          }
        });
        expect(promise.getState()).toBe('resolved');
        expect(result).toBe(fibonacci(12));
        expect(targetFunction).toHaveBeenCalled();
        targetFunction.reset();
        result = null;
        promise = memoFunction(12);
        promise.then({
          success: function(value) {
            return result = value;
          }
        });
        expect(promise.getState()).toBe('resolved');
        expect(result).toBe(fibonacci(12));
        expect(targetFunction).not.toHaveBeenCalled();
      });
      it('should return a new function that wraps the specified function and caches the results for previously processed inputs, and returns a resolved Promise when the input is a resolved Deferred or Promise', function() {
        var memoFunction, promise, resolvedDeferred, resolvedPromise, result, targetFunction;
        targetFunction = createTargetFunction();
        memoFunction = Deft.promise.Promise.memoize(targetFunction, expectedScope);
        resolvedDeferred = new Ext.create('Deft.promise.Deferred');
        resolvedDeferred.resolve(12);
        result = null;
        promise = memoFunction(resolvedDeferred);
        promise.then({
          success: function(value) {
            return result = value;
          }
        });
        expect(promise.getState()).toBe('resolved');
        expect(result).toBe(fibonacci(12));
        expect(targetFunction).toHaveBeenCalled();
        targetFunction.reset();
        result = null;
        promise = memoFunction(resolvedDeferred);
        promise.then({
          success: function(value) {
            return result = value;
          }
        });
        expect(promise.getState()).toBe('resolved');
        expect(result).toBe(fibonacci(12));
        expect(targetFunction).not.toHaveBeenCalled();
        result = null;
        promise = memoFunction(12);
        promise.then({
          success: function(value) {
            return result = value;
          }
        });
        expect(promise.getState()).toBe('resolved');
        expect(result).toBe(fibonacci(12));
        expect(targetFunction).not.toHaveBeenCalled();
        memoFunction = Deft.promise.Promise.memoize(targetFunction, expectedScope);
        resolvedPromise = resolvedDeferred.getPromise();
        result = null;
        promise = memoFunction(resolvedPromise);
        promise.then({
          success: function(value) {
            return result = value;
          }
        });
        expect(promise.getState()).toBe('resolved');
        expect(result).toBe(fibonacci(12));
        expect(targetFunction).toHaveBeenCalled();
        targetFunction.reset();
        resolvedPromise = resolvedDeferred.getPromise();
        result = null;
        promise = memoFunction(resolvedPromise);
        promise.then({
          success: function(value) {
            return result = value;
          }
        });
        expect(promise.getState()).toBe('resolved');
        expect(result).toBe(fibonacci(12));
        expect(targetFunction).not.toHaveBeenCalled();
        result = null;
        promise = memoFunction(12);
        promise.then({
          success: function(value) {
            return result = value;
          }
        });
        expect(promise.getState()).toBe('resolved');
        expect(result).toBe(fibonacci(12));
        expect(targetFunction).not.toHaveBeenCalled();
      });
      it('should return a new function that wraps the specified function and caches the results for previously processed inputs, and returns a rejected Promise when the input is a rejected Deferred or Promise', function() {
        var memoFunction, promise, rejectedDeferred, rejectedPromise, result, targetFunction;
        targetFunction = createTargetFunction();
        memoFunction = Deft.promise.Promise.memoize(targetFunction, expectedScope);
        rejectedDeferred = new Ext.create('Deft.promise.Deferred');
        rejectedDeferred.reject('error message');
        result = null;
        promise = memoFunction(rejectedDeferred);
        promise.then({
          failure: function(value) {
            return result = value;
          }
        });
        expect(promise.getState()).toBe('rejected');
        expect(result).toBe('error message');
        expect(targetFunction).not.toHaveBeenCalled();
        memoFunction = Deft.promise.Promise.memoize(targetFunction, expectedScope);
        rejectedPromise = rejectedDeferred.getPromise();
        result = null;
        promise = memoFunction(rejectedPromise);
        promise.then({
          failure: function(value) {
            return result = value;
          }
        });
        expect(promise.getState()).toBe('rejected');
        expect(result).toBe('error message');
        expect(targetFunction).not.toHaveBeenCalled();
      });
      it('should return a new function that wraps the specified function and caches the results for previously processed inputs, and returns a pending (and immediately updated) Promise when the input is a pending (and updated) Deferred or Promise', function() {
        var memoFunction, pendingDeferred, pendingPromise, promise, result, targetFunction;
        targetFunction = createTargetFunction();
        memoFunction = Deft.promise.Promise.memoize(targetFunction, expectedScope);
        pendingDeferred = new Ext.create('Deft.promise.Deferred');
        pendingDeferred.update('progress');
        result = null;
        promise = memoFunction(pendingDeferred);
        promise.then({
          progress: function(value) {
            return result = value;
          }
        });
        expect(promise.getState()).toBe('pending');
        expect(result).toBe('progress');
        expect(targetFunction).not.toHaveBeenCalled();
        memoFunction = Deft.promise.Promise.memoize(targetFunction, expectedScope);
        pendingPromise = pendingDeferred.getPromise();
        result = null;
        promise = memoFunction(pendingPromise);
        promise.then({
          progress: function(value) {
            return result = value;
          }
        });
        expect(promise.getState()).toBe('pending');
        expect(result).toBe('progress');
        expect(targetFunction).not.toHaveBeenCalled();
      });
      it('should return a new function that wraps the specified function and caches the results for previously processed inputs, and returns a cancelled Promise when the input is a cancelled Deferred or Promise', function() {
        var cancelledDeferred, cancelledPromise, memoFunction, promise, result, targetFunction;
        targetFunction = createTargetFunction();
        memoFunction = Deft.promise.Promise.memoize(targetFunction, expectedScope);
        cancelledDeferred = new Ext.create('Deft.promise.Deferred');
        cancelledDeferred.cancel('reason');
        result = null;
        promise = memoFunction(cancelledDeferred);
        promise.then({
          cancel: function(value) {
            return result = value;
          }
        });
        expect(promise.getState()).toBe('cancelled');
        expect(result).toBe('reason');
        expect(targetFunction).not.toHaveBeenCalled();
        memoFunction = Deft.promise.Promise.memoize(targetFunction, expectedScope);
        cancelledPromise = cancelledDeferred.getPromise();
        result = null;
        promise = memoFunction(cancelledPromise);
        promise.then({
          cancel: function(value) {
            return result = value;
          }
        });
        expect(promise.getState()).toBe('cancelled');
        expect(result).toBe('reason');
        expect(targetFunction).not.toHaveBeenCalled();
      });
      it('should return a new function that wraps the specified function and caches the results for previously processed inputs, and returns a pending Promise when the input is a pending Deferred or Promise, and where that pending Promise resolves when the specified Deferred or Promise is resolved', function() {
        var memoFunction, pendingDeferred, pendingPromise, promise, result, targetFunction;
        targetFunction = createTargetFunction();
        memoFunction = Deft.promise.Promise.memoize(targetFunction, expectedScope);
        pendingDeferred = new Ext.create('Deft.promise.Deferred');
        result = null;
        promise = memoFunction(pendingDeferred);
        promise.then(function(value) {
          return result = value;
        });
        expect(promise.getState()).toBe('pending');
        pendingDeferred.resolve(12);
        expect(promise.getState()).toBe('resolved');
        expect(result).toBe(fibonacci(12));
        expect(targetFunction).toHaveBeenCalled();
        targetFunction.reset();
        pendingDeferred = new Ext.create('Deft.promise.Deferred');
        result = null;
        promise = memoFunction(pendingDeferred);
        promise.then(function(value) {
          return result = value;
        });
        expect(promise.getState()).toBe('pending');
        pendingDeferred.resolve(12);
        expect(promise.getState()).toBe('resolved');
        expect(result).toBe(fibonacci(12));
        expect(targetFunction).not.toHaveBeenCalled();
        memoFunction = Deft.promise.Promise.memoize(targetFunction, expectedScope);
        pendingDeferred = new Ext.create('Deft.promise.Deferred');
        pendingPromise = pendingDeferred.getPromise();
        result = null;
        promise = memoFunction(pendingPromise);
        promise.then({
          success: function(value) {
            return result = value;
          }
        });
        expect(promise.getState()).toBe('pending');
        pendingDeferred.resolve(12);
        expect(promise.getState()).toBe('resolved');
        expect(result).toBe(fibonacci(12));
        expect(targetFunction).toHaveBeenCalled();
        targetFunction.reset();
        pendingDeferred = new Ext.create('Deft.promise.Deferred');
        pendingPromise = pendingDeferred.getPromise();
        result = null;
        promise = memoFunction(pendingPromise);
        promise.then({
          success: function(value) {
            return result = value;
          }
        });
        expect(promise.getState()).toBe('pending');
        pendingDeferred.resolve(12);
        expect(promise.getState()).toBe('resolved');
        expect(result).toBe(fibonacci(12));
        expect(targetFunction).not.toHaveBeenCalled();
      });
      it('should return a new function that wraps the specified function and caches the results for previously processed inputs, and returns a pending Promise when the input is a pending Deferred or Promise, and where that pending Promise rejects when the specified Deferred or Promise is rejected', function() {
        var memoFunction, pendingDeferred, pendingPromise, promise, result, targetFunction;
        targetFunction = createTargetFunction();
        memoFunction = Deft.promise.Promise.memoize(targetFunction, expectedScope);
        pendingDeferred = new Ext.create('Deft.promise.Deferred');
        result = null;
        promise = memoFunction(pendingDeferred);
        promise.then({
          failure: function(value) {
            return result = value;
          }
        });
        expect(promise.getState()).toBe('pending');
        pendingDeferred.reject('error message');
        expect(promise.getState()).toBe('rejected');
        expect(result).toBe('error message');
        expect(targetFunction).not.toHaveBeenCalled();
        memoFunction = Deft.promise.Promise.memoize(targetFunction, expectedScope);
        pendingDeferred = new Ext.create('Deft.promise.Deferred');
        pendingPromise = pendingDeferred.getPromise();
        result = null;
        promise = memoFunction(pendingPromise);
        promise.then({
          failure: function(value) {
            return result = value;
          }
        });
        expect(promise.getState()).toBe('pending');
        pendingDeferred.reject('error message');
        expect(promise.getState()).toBe('rejected');
        expect(result).toBe('error message');
        expect(targetFunction).not.toHaveBeenCalled();
      });
      it('should return a new function that wraps the specified function and caches the results for previously processed inputs, and returns a pending Promise when the input is a pending Deferred or Promise, and where that pending Promise updates when the specified Deferred or Promise is updated', function() {
        var memoFunction, pendingDeferred, pendingPromise, promise, result, targetFunction;
        targetFunction = createTargetFunction();
        memoFunction = Deft.promise.Promise.memoize(targetFunction, expectedScope);
        pendingDeferred = new Ext.create('Deft.promise.Deferred');
        result = null;
        promise = memoFunction(pendingDeferred);
        promise.then({
          progress: function(value) {
            return result = value;
          }
        });
        expect(promise.getState()).toBe('pending');
        pendingDeferred.update('progress');
        expect(promise.getState()).toBe('pending');
        expect(result).toBe('progress');
        expect(targetFunction).not.toHaveBeenCalled();
        memoFunction = Deft.promise.Promise.memoize(targetFunction, expectedScope);
        pendingDeferred = new Ext.create('Deft.promise.Deferred');
        pendingPromise = pendingDeferred.getPromise();
        result = null;
        promise = memoFunction(pendingPromise);
        promise.then({
          progress: function(value) {
            return result = value;
          }
        });
        expect(promise.getState()).toBe('pending');
        pendingDeferred.update('progress');
        expect(promise.getState()).toBe('pending');
        expect(result).toBe('progress');
        expect(targetFunction).not.toHaveBeenCalled();
      });
      it('should return a new function that wraps the specified function and caches the results for previously processed inputs, and returns a pending Promise when the input is a pending Deferred or Promise, and where that pending Promise cancels when the specified Deferred or Promise is cancelled', function() {
        var memoFunction, pendingDeferred, pendingPromise, promise, result, targetFunction;
        targetFunction = createTargetFunction();
        memoFunction = Deft.promise.Promise.memoize(targetFunction, expectedScope);
        pendingDeferred = new Ext.create('Deft.promise.Deferred');
        result = null;
        promise = memoFunction(pendingDeferred);
        promise.then({
          cancel: function(value) {
            return result = value;
          }
        });
        expect(promise.getState()).toBe('pending');
        pendingDeferred.cancel('reason');
        expect(promise.getState()).toBe('cancelled');
        expect(result).toBe('reason');
        expect(targetFunction).not.toHaveBeenCalled();
        memoFunction = Deft.promise.Promise.memoize(targetFunction, expectedScope);
        pendingDeferred = new Ext.create('Deft.promise.Deferred');
        pendingPromise = pendingDeferred.getPromise();
        result = null;
        promise = memoFunction(pendingPromise);
        promise.then({
          cancel: function(value) {
            return result = value;
          }
        });
        expect(promise.getState()).toBe('pending');
        pendingDeferred.cancel('reason');
        expect(promise.getState()).toBe('cancelled');
        expect(result).toBe('reason');
        expect(targetFunction).not.toHaveBeenCalled();
      });
    };
    describe('(omitting the optional scope and hash function parameters)', function() {
      createSpecsForScope();
    });
    describe('(specifying the scope to execute the memoized function in via the optional scope parameter)', function() {
      var expectedScope;
      expectedScope = {};
      createSpecsForScope(expectedScope);
    });
  });
  describe('map()', function() {
    var cancelCallback, failureCallback, progressCallback, successCallback;
    successCallback = failureCallback = progressCallback = cancelCallback = null;
    return beforeEach(function() {
      successCallback = jasmine.createSpy('success callback');
      failureCallback = jasmine.createSpy('failure callback');
      progressCallback = jasmine.createSpy('progress callback');
      cancelCallback = jasmine.createSpy('cancel callback');
    });
  });
  describe('reduce()', function() {
    var cancelCallback, failureCallback, progressCallback, successCallback;
    successCallback = failureCallback = progressCallback = cancelCallback = null;
    return beforeEach(function() {
      successCallback = jasmine.createSpy('success callback');
      failureCallback = jasmine.createSpy('failure callback');
      progressCallback = jasmine.createSpy('progress callback');
      cancelCallback = jasmine.createSpy('cancel callback');
    });
  });
  describe('then()', function() {
    var cancelCallback, failureCallback, progressCallback, scope, successCallback;
    successCallback = failureCallback = progressCallback = cancelCallback = scope = null;
    beforeEach(function() {
      successCallback = jasmine.createSpy('success callback');
      failureCallback = jasmine.createSpy('failure callback');
      progressCallback = jasmine.createSpy('progress callback');
      cancelCallback = jasmine.createSpy('cancel callback');
      scope = {};
    });
    return it('should call through to the underlying Deferred\'s then() method with the same specified parameters and return the same result', function() {
      var deferred, expectedReturnValue, promise;
      deferred = Ext.create('Deft.promise.Deferred');
      promise = deferred.getPromise();
      expectedReturnValue = {};
      spyOn(deferred, 'then').andReturn(expectedReturnValue);
      expect(promise.then(successCallback, failureCallback, progressCallback, cancelCallback, scope)).toBe(expectedReturnValue);
      expect(deferred.then).toHaveBeenCalledWith(successCallback, failureCallback, progressCallback, cancelCallback, scope);
      expect(promise.then({
        success: successCallback,
        failure: failureCallback,
        progress: progressCallback,
        cancel: cancelCallback,
        scope: scope
      })).toBe(expectedReturnValue);
      expect(deferred.then).toHaveBeenCalledWith({
        success: successCallback,
        failure: failureCallback,
        progress: progressCallback,
        cancel: cancelCallback,
        scope: scope
      });
    });
  });
  describe('otherwise()', function() {
    var otherwiseCallback, scope;
    otherwiseCallback = scope = null;
    beforeEach(function() {
      otherwiseCallback = jasmine.createSpy('otherwise callback');
      scope = {};
    });
    return it('should call through to the underlying Deferred\'s otherwise() method with the same specified parameters and return the same result', function() {
      var deferred, expectedReturnValue, promise;
      deferred = Ext.create('Deft.promise.Deferred');
      promise = deferred.getPromise();
      expectedReturnValue = {};
      spyOn(deferred, 'otherwise').andReturn(expectedReturnValue);
      expect(promise.otherwise(otherwiseCallback, scope)).toBe(expectedReturnValue);
      expect(deferred.otherwise).toHaveBeenCalledWith(otherwiseCallback, scope);
      expect(promise.otherwise({
        fn: otherwiseCallback,
        scope: scope
      })).toBe(expectedReturnValue);
      expect(deferred.otherwise).toHaveBeenCalledWith({
        fn: otherwiseCallback,
        scope: scope
      });
    });
  });
  describe('always()', function() {
    var alwaysCallback, scope;
    alwaysCallback = scope = null;
    beforeEach(function() {
      alwaysCallback = jasmine.createSpy('always callback');
      scope = {};
    });
    return it('should call through to the underlying Deferred\'s otherwise() method with the same specified parameters and return the same result', function() {
      var deferred, expectedReturnValue, promise;
      deferred = Ext.create('Deft.promise.Deferred');
      promise = deferred.getPromise();
      expectedReturnValue = {};
      spyOn(deferred, 'always').andReturn(expectedReturnValue);
      expect(promise.always(alwaysCallback, scope)).toBe(expectedReturnValue);
      expect(deferred.always).toHaveBeenCalledWith(alwaysCallback, scope);
      expect(promise.always({
        fn: alwaysCallback,
        scope: scope
      })).toBe(expectedReturnValue);
      expect(deferred.always).toHaveBeenCalledWith({
        fn: alwaysCallback,
        scope: scope
      });
    });
  });
  return describe('cancel()', function() {
    return it('should call through to the underlying Deferred\'s cancel() method with the same specified parameters and return the same result', function() {
      var deferred, expectedReturnValue, promise;
      deferred = Ext.create('Deft.promise.Deferred');
      promise = deferred.getPromise();
      expectedReturnValue = {};
      spyOn(deferred, 'cancel').andReturn(expectedReturnValue);
      expect(promise.cancel('reason')).toBe(expectedReturnValue);
      expect(deferred.cancel).toHaveBeenCalledWith('reason');
    });
  });
});
